# Analyzing Survey Data

```{r warning=FALSE, message=FALSE, include=FALSE}
library(tidyverse)
library(survey)
library(janitor)
library(flextable)
```

This is a tutorial for using the **survey** package to analyze complex survey data. "Complex" surveys are those with stratification and/or clustering. The package handles weights, and adjusts statistical tests for the survey design.

## Defining the Survey Design

Below are some examples defining the most common survey designs. The **survey** package includes the *Student performance in California schools* data set (`api`), a record of the Academic Performance Index based on standardized testing. `api` contains sub-data sets that illustrate the design types.

* `apisrs` is a simple random sample of (*n* = 200) schools, 
* `apistrat` is stratified sample of 3 school types (elementary, middle, high) with simple random sampling of different sizes in each stratum, 
* `apiclus2` is a two-stage cluster sample of schools within districts.

```{r include=FALSE}
data(api, package = "survey")
```

You create a survey design object with the `svydesign(data, ...)` function. There are parameter settings for each design type.

### Simple Random Sample

A simple random sample has no clusters, so indicate this with `ids = ~1`. The response weights will always be the same, equaling the population size divided by the sample size. Typically, the response weight is identified in a column. There is another parameter called the finite population correction (`fpc`) that is used to reduce the variance when a substantial fraction of the total population has been sampled. Set `fpc` to the stratum population size. A simple random sample has no strata, so it will always be the same, equaling the population size.

For `apisrs` the population size is 6,194 (the number of schools in California). The sample size is 200, so the response weights all equal 6,194 / 200 = 30.97. 

```{r collapse=TRUE}
nrow(apisrs)
apisrs %>% count(pw, fpc)
```

Here is the design object.

```{r collapse=TRUE}
apisrs_design <- svydesign(
  data = apisrs, 
  weights = ~pw, 
  fpc = ~fpc, 
  ids = ~1
)
summary(apisrs_design)
```

### Stratified Sample

Define a stratified sample by specifying with the `strata` parameter. The schools in `apistrat` are stratified based on the school type *E* = Elementary, *M* = Middle, and *H* = High School. For each school type, a simple random sample of schools was taken: $n_E$ = 100, $n_M$ = 50, and $n_H$ = 50. The 100 elementary schools represent 100 / 4,421 of the state's elementary schools, so their weights = 44.21. Similarly, the weights are 50 / 1,018 = 20.36 for the middle schools, and 50 / 755 = 15.10 for the high schools.

```{r}
apistrat %>% 
  count(stype, pw, fpc) %>% 
  mutate(`pw*n` = pw * n) %>%
  adorn_totals(,,,, -pw) %>% 
  flextable() %>% colformat_num(j = 2, digits = 2) %>% colformat_int(j = c(3:5))
```

Here is the design object.

```{r}
apistrat_design <- svydesign(
  data = apistrat, 
  weights = ~pw, 
  fpc = ~fpc, 
  ids = ~1, 
  strata = ~stype
)
summary(apistrat_design)
```

### Clustered

Define a clustered sample by specifying the the cluster `ids` from largest to smallest level. The schools in `apiclus2` are clustered in two stages, first by the (`fpc1` = 757) school districts and a random sample of (*n* = 40) school districts (`dnum`) were selected. Then a random sample of (*n* <= 5) schools (`snum`) were selected from the `fpc2` schools in the selected school districts.

```{r}
apiclus_design <- svydesign(
  id = ~dnum + snum, 
  data = apiclus2, 
  weights = ~pw, 
  fpc = ~fpc1 + fpc2
)
summary(apiclus_design)
```

### Example: NHANES

Let's create a complex survey design for the National Health and Nutrition Examination Survey (NHANES). The survey collected 78 attributes of (*n* = 20,293) persons.

```{r}
data(NHANESraw, package = "NHANES")
NHANESraw <- NHANESraw %>% 
  mutate(WTMEC4YR = WTMEC2YR / 2) # correction to weights
```

The survey used a 4-stage design: stage 0 stratified the US by geography and proportion of minority populations; stage 1 randomly selected counties within strata; stage 2 randomly seleted city blocks within counties; stage 3 randomly selected households within city blocks; and stage 4 randomly selected persons within households. When there are multiple levels of clusters like this, the convention is to assign the first cluster to `ids`. Set `nest = TRUE` because the cluster ids are nested within the strata (i.e., they are not unique).

```{r}
NHANES_design <- svydesign(
  data = NHANESraw, 
  strata = ~SDMVSTRA, 
  ids = ~SDMVPSU, 
  nest = TRUE, 
  weights = ~WTMEC4YR
)
summary(NHANES_design)
```

Survey weights for minorities are typically lower to account for their large sample sizes relative to population representation. You can see how the weights sum to the sub-populations and the total population.

```{r}
NHANESraw %>% 
  group_by(Race1) %>% 
  summarize(.groups = "drop", 
            `Sum(WTMEC4YR)` = sum(WTMEC4YR), 
            `Avg(WTMEC4YR)` = mean(WTMEC4YR), 
            n = n()) %>%
  mutate(`Avg * n` = `Avg(WTMEC4YR)` * n) %>%
  janitor::adorn_totals(where = "row") %>%
  flextable::flextable() %>%
  flextable::colformat_int(j = c(2:5))
```

The **survey** package functions handle the survey designs and weights. The population figures from the table above could have been built with `svytable()`.

```{r}
svytable(~Race1, design = NHANES_design) %>%
  as.data.frame() %>%
  mutate(prop = Freq / sum(Freq) * 100) %>%
  arrange(desc(prop)) %>%
  adorn_totals() %>%
  flextable() %>%
  colformat_int(j = 2) %>%
  colformat_num(j = 3, suffix = "%", digits = 0)
```

## Exploring Categorical Items

Create a contingency table by including two variables in `svytable()`. Here is contingency table for self-reported health by depression expressed as a 100% stacked bar chart.

```{r}
svytable(~Depressed + HealthGen, design = NHANES_design) %>%
  data.frame() %>%
  group_by(HealthGen) %>%
  mutate(n_HealthGen = sum(Freq), Prop_Depressed = Freq / sum(Freq)) %>%
  ggplot(aes(x = HealthGen, y = Prop_Depressed, fill = Depressed)) +
  geom_col() + 
  coord_flip() +
  theme_minimal() +
  scale_fill_brewer()
```

Perform a chi-square test of independence on contingency tables using the `svychisq()` function. Here is a test ofthe null hypothesis that depression is independent of general health.

```{r}
svychisq(~Depressed + HealthGen, design = NHANES_design, statistic = "Chisq")
```

The chi-square test with Rao & Scott adjustment is evidently not a standard chi-square test. *Maybe in how it factors in survey design?* The test statistic is usually $X^2 = \sum (O - E)^2 / E.$

```{r collapse=TRUE}
O <- svytable(~Depressed + HealthGen, design = NHANES_design) %>% as.matrix()
E <- sum(O) * prop.table(O, 1) * prop.table(O, 2)
(X2 <- sum((O - E)^2 / E))
pchisq(X2, df = (nrow(O)-1) * (ncol(O) - 1), lower.tail = FALSE)
```

which is what `chisq.test()` does.

```{r}
svytable(~Depressed + HealthGen, design = NHANES_design) %>% 
  as.matrix() %>% 
  chisq.test()
```


## Exploring Quantitative Data

The `svymean()`, `svytotal()`, and `svyquantile()` functions summarize quantitative variables. To group by a factor variable, use `svyby()`.

```{r}
svyquantile(x = ~SleepHrsNight, 
            design = NHANES_design, 
            na.rm = TRUE, 
            quantiles = c(.01, .25, .50, .75, .99))

svymean(x = ~SleepHrsNight, design = NHANES_design, na.rm = TRUE)
```

```{r}
svyby(formula = ~SleepHrsNight, by = ~Depressed, FUN = svymean, 
      design = NHANES_design, na.rm = TRUE, keep.names = FALSE) %>%
  ggplot(aes(x = Depressed, y = SleepHrsNight, 
             ymin = SleepHrsNight - 2*se, ymax = SleepHrsNight + 2*se)) +
  geom_col(fill = "lightblue") +
  geom_errorbar(width = 0.5)
```

You need raw data for the distribution plots, so be sure to weight the variables.

```{r}
NHANESraw %>% 
  ggplot(aes(x = SleepHrsNight, weight = WTMEC4YR)) + 
  geom_histogram(binwidth = 1, fill = "lightblue", color = "#FFFFFF", na.rm = TRUE)

NHANESraw %>% 
  filter(!is.na(SleepHrsNight) & !is.na(Gender)) %>%
  group_by(Gender) %>%
  mutate(WTMEC4YR_std = WTMEC4YR / sum(WTMEC4YR)) %>%
  ggplot(aes(x = SleepHrsNight, Weight = WTMEC4YR_std)) +
  geom_density(bw = 0.6, fill = "lightblue") +
  labs(x = "Sleep Hours per Night") +
  facet_wrap(~Gender, labeller = "label_both")
```

Test whether the population averages differ with a two-sample survey-weighted t-test. Use the `svytest()` function to incorporate the survey design.

```{r}
svyttest(formula = SleepHrsNight ~ Gender, design = NHANES_design)
```

## Modeling Quantitative Data

Scatterplots need to adjust for the sampling weights. You can do this with the `size` or `alpha` aesthetics.

```{r}
p1 <- NHANESraw %>% 
  filter(Age == 20) %>%
  ggplot(aes(x = Height, y = Weight, color = Gender, size = WTMEC4YR)) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.3) +
  guides(size = FALSE) +
  theme(legend.position = "top") +
  labs(color = "")

p2 <- NHANESraw %>% 
  filter(Age == 20) %>%
  ggplot(aes(x = Height, y = Weight, color = Gender, alpha = WTMEC4YR)) +
  geom_jitter(width = 0.3, height = 0) +
  guides(alpha = FALSE) +
  theme(legend.position = "top") +
  labs(color = "")

gridExtra::grid.arrange(p1, p2, nrow = 1)
```

Fit a regression line with `geom_smooth()`.

```{r}
NHANESraw %>% 
  filter(!is.na(Weight) & !is.na(Height)) %>%
  ggplot(aes(x = Height, y = Weight, size = WTMEC4YR)) +
  geom_point(alpha = 0.1) +
  geom_smooth(method = "lm", se = FALSE, mapping = aes(weight = WTMEC4YR), 
              formula = y ~ x, color = "blue") +
  geom_smooth(method = "lm", se = FALSE, mapping = aes(weight = WTMEC4YR), 
              formula = y ~ poly(x, 2), color = "orange") +
  geom_smooth(method = "lm", se = FALSE, mapping = aes(weight = WTMEC4YR), 
              formula = y ~ poly(x, 3), color = "red") +
guides(size = FALSE) 
```

Model a regression line with `svyglm()`. Let's build a model to predict, BPSysAve, a person's systolic blood pressure reading, using BPDiaAve, a person's diastolic blood pressure reading and Diabetes, whether or not they were diagnosed with diabetes.

```{r}
drop_na(NHANESraw, Diabetes, BPDiaAve, BPSysAve) %>%
ggplot(mapping = aes(x = BPDiaAve, y = BPSysAve, size = WTMEC4YR, color = Diabetes)) + 
    geom_point(alpha = 0.2) + 
    guides(size = FALSE) + 
    geom_smooth(method = "lm", formula = y ~ x, se = FALSE, mapping = aes(weight = WTMEC4YR))

mod <- svyglm(BPSysAve ~ BPDiaAve*Diabetes, design = NHANES_design)
summary(mod)
```

